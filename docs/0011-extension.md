revision: 3

---

## Groundwork

Upon app initialization, a device will generate it's own keypair. This keypair will stay the same for the lifespan of
storage on the device, or up until the owner of the device decides to invalidate that keypair. A party implementing this
specification may decide whether or not the application will support multiple keypairs, how to achieve this
functionality is not covered in this specification.

An identity is known by a 256-bit sequence, generated by the performing a sha3-256 on `iat|iss` where `|` is the
concatenation of the issued_at and issuer fields. Doing this ensures only the device knowing the associated private key
of the issuer can initialize that specific identifier. Although this limits identity initialization to 1 identity per
keypair per second, this is not seen as an issue.

Each piece of data within the network will be called a "document", which in on-the-wire representation will be 3
base64url-encoded blobs representing the header, body, and signature, separated by period (0x2E) characters, similar to
the encoding scheme used by [jwt][jwt.io]

The header internally is structured in a text-based tuple format, somewhat like [http headers][rfc2616#headers], but
using line feed (0x0A) characters instead of a CRLF sequence to represent line breaks. This simplified format was chosen
to allow for lightweight implementations participating in the network without having to support parsing any advanced
encodings and to reduce processing requirements (a nice-to-have would be to allow even an atmega328 with a serial
connection and some storage to participate).

Signatures cover the wire-encoded version of document headers and bodies including the period separator, similar to jwt,
to remove the need within implementations to keep keys in order during parsing.

Documents themselves will signify what type of document they are in their header, so if a document is received without
any further metadata, it can still be acted upon in the correct manner, reducing the metadata requirements in transfer
protocols.

Although the protocol and data storage may resemble scuttlebut, we are not aiming for compatibility nor should it be
expected.

### Key notation

Because we want to support multiple public key algorithms, we're choosing a notation scheme for public keys that
resembles [the notation used by the scuttlebut protocol][sb#keys], but using the base64url character set without padding
instead of the regular base64 character set.

For now, we'll just be calling this the human-readable notation, although some fancy name might be chosen in the future.

```
@nsykPbQ48deciLmJ9K5Q0Vvmz8u8mfQaJWo_uufJ1AM.ed25519
```

### Known issues

- Key revocation:

  A key may be revoked on an identity, but there's nothing stopping the leaked key being used for generating a stronger
  chain. Maybe have the client "trust" new keys manually or be vouched for by another key+identity they trust?

- Content-Type:

  We have not defined a specific mimetype for single or multi-document transfers for use in things like http. For now,
  we'll be using `application/x-nd-b64u-doc` as a placeholder, meaning newline-delimited-base64url-document, if we need
  to showcase a transfer using the http protocol.

## Document structure

As mentioned in the groundwork section, a document consists of 3 components: header, body, signature

### Document types

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>profile</td>
      <td>
        <details>
          <summary>Collection of fields for the public display of an entity</summary>
          <h3>Contents</h3>
          <p>
            No profile structures have been defined yet, though a multipart/alternative would make sense to support
            multiple representations (like having a pre-rendered text/plain profile for cli tools, a text/vcard for
            integration and an application/json-ld profile for display, or even nest a multipart/mixed for attachments
            like a profile-picture)
          </p>
        </details>
      </td>
    </tr>
    <tr>
      <td>certificate</td>
      <td>
        <details>
          <summary>Granting or revoking key usages on an identity</summary>
          <h3>Contents</h3>
          <p>
            To be defined later.
          </p>
        </details>
      </td>
    </tr>
  </tbody>
</table>

### Headers

In this specification, we will always show header keys to be lowercase only. When encoding, implementations SHOULD
always encode headers in lowercase, but MUST parse them in a case-insensitive manner.

This list is **not** a complete list, just a list of common headers.

| Header            | Description                                                          |
| ----------------- | -------------------------------------------------------------------- |
| document-type     | Required, specifies the document type                                |
| document-issuer   | Required, human-readable public key that issued the document         |
| document-identity | Required, identity hash associated with this document                |
| document-expires  | Optional, unix timestamp in seconds until when the document is valid |
| content-type      | Mime-type of the document body if applicable                         |

## Profiles

Like described in the document types, a profile is simply a representation of an identity. Multiple representations may
exist, like a pre-rendered text/plain representation and/or a application/json-ld version.

For example, if you set content-type to `multipart/alternative; boundary=deadbeef`, a profile containing a text and
vcard representation could look like this:

```
This part is pre-document and SHOULD NOT be used. Reserved for future extension

--deadbeef
content-type: text/plain; charset=utf-8

Name: finwo
URL : https://finwo.nl

About me:

Just a developer working on his empire, one keystroke at a time.

--deadbeef
content-type: text/vcard

BEGIN
VERSION:4.0
FN:finwo
URL:https://finwo.nl
NOTE:Just a developer working on his empire, one keystroke at a time.
END

--deadbeef--

This part is post-document and SHOULD NOT be used. Reserved for future extension
```

## Certificates

Certificates have a text-based structure



















revision: 2

---


### Known issues

The current rough sketch is to add something like a "sequence" or "previous" field to the "policy" documents only, and defining that policy
documents not building on top of the current "head" must be rejected by nodes within the network, but this does not prevent forks in the chain.

Another possible solution to this would be to build a network of trust, somewhat like certificate authorities, where the authority can vouch
for certain keys on a profile, instead of self-declaring with policies

### In-transit data definition

On the wire, because most requests will be dealing with multiple entities or messages, we suggest encoding the content + signature
in base64url format separated by a period character, like jwt but with merged headers and body. We haven't checked what mimetype that
might be, to we'll be using `application/x-nd-b64u-doc` (ndc = newline-delimited-base64url-document) in this document.

Using random data as content and signatures (because we haven't defined that yet), a request-response sequence may look somewhat like this:

```
> GET /identity/dead...beef/chain HTTP/1.1
> accept: application/x-nd-b64u-doc
..
< HTTP/1.1 200 OK
< content-type: application/x-nd-b64u-doc
<
< eeeFokKRO7fLJSeCQhZae-275DfSnl5y8ZfORIKL5UY.G2hchoWEYepNsP0OXFi7CDpVQ1nfboW487nqwneot6k
< sdBWHr8u7iLaReBhWqoA2azT_f4314NZt158W1E7tTE.OfGQ3HCaUixqrwYtCiw9aT0QN2PuDFIoZzsjMyaEJ74
```

Off course, it's unlikely that we'll be using http in the peer-to-peer network we want to set up, but it's a start of defining in-transit data

### Document types

As mentioned above, each document contains a blob of headers+body and a blob of the signature. The signature is made on the raw headers+body,
not on the encoded headers+body, so the in-transit encoding can be modified later.

Because we don't have to care about legacy, as this is a new protocol definition, here's a list of the defined headers:

| Header | Name                   | Description                                          | Example                                        |
| ------ | ---------------------- | ---------------------------------------------------- | ---------------------------------------------- |
| sub    | subject                | Resource descriptor for the document                 | rd:&lt;doctype&gt;:&lt;identifier&gt;          |
| cty    | content type           | Base format of the body of the document              | application/json                               |
| iss    | issuer key             | Which pubkey issued the document                     | rd:pubkey:&lt;algorithm&gt;.&lt;pubkeydata&gt; |
| iat    | issued at              | Timestamp in seconds of when the document was issued | 1722367969                                     |
| kex    | key exchange parameter | Public parameter for key exchange purposes           | CDCDCD                                         |

To ensure compatibility across different clients, all document types not defined in this (or future) specifications should be rejected,
and the defined document types are only allowed to have the following content types:

| Doctype  | cty                           | Description                  |
| -------- | ----------------------------- | ---------------------------- |
| identity | application/json              | Defines an identity          |
| message  | text/plain OR multipart/mixed | A message between identities |
| policy   | application/json              | Policy definition            |

Policies and messages don't have a unique resource descriptor, they should be stored as a list under their related identity.

### Policy actions

Here's a quick list of defined actions

| Action | Description                                                             |
| ------ | ----------------------------------------------------------------------- |
| *      | All actions, allow or deny all actions on a resource, excluding `inbox` |
| inbox  | Define the principal as being the inbox key for messages                |

## Document examples

Like already mentioned, documents have a blob containing both headers and a body. We're borrowing heavily from http and smtp in these
definitions. As a newline, we're using `\n`, not `\r\n`. In these examples, we're using `deadbeef` and `abadcafe` as arbitraty hex values.

### New policy

This example declares a new policy. This policy declaration is also used as initializing a new identity if the principal field
is the same as the iss, the resource is `rd:identity:<sha3-256(iat|iss).hex>` and the `actions` are defined as `["*"]` or `["*","inbox"]`

The main reason for this behavior is that it prevents bad actors from granting themselves permissions on pre-existing identities.
Although this limits initializing identities from a single keypair to 1 per second, this is not seen as an issue.

```
sub: rd:identity:deadbeef/policy
iss: rd:pubkey:supercop.abadcafe
iat: 1722367969
cty: application/json

{
  "principal": "rd:pubkey:supercop.abadcafe",
  "actions"  : ["*"],
  "resource" : "rd:identity:deadbeef",
  "effect"   : "allow"
}
```

```
sub: rd:identity:c0ffee/policy
iss: rd:pubkey:supercop.deadc0de
iat: 1722367969
cty: application/json

{
  "principal": "rd:pubkey:supercop.deadc0de",
  "actions"  : ["*","inbox"],
  "resource" : "rd:identity:c0ffee",
  "effect"   : "allow"
}
```

### Profile update

While multiple versions of a profile may be stored, only the most recent one should be used for display purposes

```
sub: rd:identity:deadbeef/profile
iss: rd:pubkey:supercop.abadcafe
iat: 1722367970
cty: application/json

{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name"
  },
  "name": "finwo"
}
```

### Message

This document represents a message from identity deadbeef using supercop.abadcafe to identity c0ffee. While messages SHOULD be
encrypted using key-exchange between the cryptographic keys, it's not a requirement. The `dst` field shows spaces, but this is
for clarity in the example, the real value must not contain spaces between the key, at, and identity.

```
sub: rd:identity:deadbeef/outbox
iss: rd:pubkey:supercop.abadcafe
dst: rd:pubkey:supercop.deadc0de @ rd:identity:c0ffee
iat: 1722367971
cty: text/plain

Hello coffee, how are you doing today?
```




















revision: 1

---

For complex content you could even use the `multipart/mixed; boundary=xxx` content type to have multiple formattings
For example, if we request a whole chain from a remote node over http in json-ld format, a request-response pair may look something like this:

```
> GET /identity/dead...beef/chain HTTP/1.1
> host: localhost
> accept: application/json-ld
..
< HTTP/1.1 200 OK
< content-type: application/json-ld

< x-signature: FMb5yAaJIsn5sNOoYvFK8SHL1sdZ8qJpjCNl5RFfQzU
< content-type: application/octet-stream
<
<

```

Borrowing ideas from protocols like HTTP and SMTP, the headers are in a basic tuple-coded format.
This allows the protocol to be extended later. Headers SHOULD be encoded all lowercase, and parsing
MUST be done in a case-insensitive manner.

Unlike [jwt](https://jwt.io),
The signature covers the base64url-encoded data, just like [jwt](https://jwt.io).

Example headers:

```
content-type: application/json
x-issuer: <issuer-pubkey> '.' <issuer-algorithm>
```

The body can be different content types, to allow the same encoding structure for both core data and multimedia posts
For complex content you could even use the `multipart/mixed; boundary=xxx` content type to have multiple formattings
in the same post, or like a video together with it's description and multiple subtitle options.

But, for predefined data structures we require no content-encoding and a content-type of `application/json`,
so all clients implementing the protocol can work with keychains and other verification tools.




  - `/identity/dead...beef`

    The basic identity

    ```

    ```

  - `/identity/dead...beef/chain`

    The keychain of the `dead...beef` identity, for which the digest as described above matches the first key/line.
    Lines/certificates can **not** be removed from the keychain and must be in chronological order.
    The same pubkey can occur multiple times for the purpose of granting/revoking additional permissions.
    It's the client's responsibility to keep an index of which key has permissions on which identity, this is NOT part of the protocol.

    Each line is it's own entity/certificate,
    , a json-encoded record with the following fields:

    ```
    {
      "iss": "<issuer-algorithm>:<issuer-pubkey>",
      "sub": "<subject-algorithm>:<subject-pubkey>",
      "xcr": "<root-algorithm>:<root-pubkey>",
      "iat": <issued-at-timestamp-in-seconds>,
      "exp": <optional-expiry-timestamp-in-seconds>,
      "usg": "<optional-usage-key>|<optional-usage-key>"
    }
    '.' <signature-by-issuer>
    ```

  - `/identity/dead...beef/outbox`

    Outgoing



[jwt.io]: https://jwt.io
[rfc2616#headers]: https://www.rfc-editor.org/rfc/rfc2616#page-31
[sb#keys]: https://ssbc.github.io/scuttlebutt-protocol-guide/#keys-and-identities
